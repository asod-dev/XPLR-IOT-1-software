#!/usr/bin/env python

'''Wrapper to present u_agent as an RPyC service.'''

import queue
import sys      # For stdout, argv and executable
import os       # For sep, path(), makedirs(), remove(), execv()
import json     # So that we can save dynamic status to file
from copy import deepcopy
import argparse
import subprocess
from multiprocessing import freeze_support
from time import sleep
from threading import Lock
from signal import signal, SIGINT, SIG_IGN  # for signal_handler
import requests # For HTTP file uploads
from requests_toolbelt.multipart.encoder import MultipartEncoder
import rpyc     # RPyC, mmmmm :-)
import u_agent  # The agent stuff itself
import u_utils

# The prompt to use if no name is given for this agent
PROMPT_DEFAULT = "u_agent_service"

# Prefix to put at the start of all prints
PROMPT = PROMPT_DEFAULT + ": "

# The port that this agent service runs on
AGENT_SERVICE_PORT = u_utils.AGENT_SERVICE_PORT

# The maxium number of characters from a controller name
# that will be used when constructing the working path
AGENT_WORKING_SUBDIR_CONTROLLER_NAME_MAX_LENGTH = u_utils.AGENT_WORKING_SUBDIR_CONTROLLER_NAME_MAX_LENGTH

# The maximum length of the working subdirectory
# name generated by _working_subdir_path_create()
# Must be longer than
# AGENT_WORKING_SUBDIR_CONTROLLER_NAME_MAX_LENGTH,
# see _working_subdir_path_create() for details
AGENT_WORKING_SUBDIR_MAX_LENGTH = 16

# The directory name to use for the test instances within
# _working_subdir_path_create()
AGENT_INSTANCES_SUBDIR_NAME = "instances"

# The sub-directory into which to place the fetched ubxlib code
AGENT_UBXLIB_SUBDIR = "ubxlib"

# Default time to wait for activity to finish
# before forcing shutdown for a clean
AGENT_CLEAN_WAIT_SECONDS = 3600 * 2

# Period between checks on agent status
AGENT_CHECK_PERIOD_SECONDS = 30

# The name to use for a status file
AGENT_DYNAMIC_STATUS_FILE_NAME = "_agent_dynamic_status.json"

# Rotate a string.
def rotate_string(string):
    '''Rotate a string'''
    string_list = list(string)
    return str(string_list.append(string_list.pop(0)))

# The agent service, to be run under RPyC.
class AgentService(rpyc.Service):
    '''Class that defines a ubxlib agent as a service'''

#########################################################
# PYTHON MAGIC METHODS
#########################################################

    def __init__(self, working_dir, name, unity_dir,
                 window_debug_file_name, window_debug_tailed_lines,
                 instances, process_pool):
        u_agent.init()
        self._working_dir = working_dir
        self._name = name
        self._clean_lock = Lock()
        self._connection_count = 0
        self._controller_name = None
        self._unity_dir = unity_dir
        self._run_called = 0
        self._instances_supported = deepcopy(instances)
        self._instances_activated = deepcopy(instances)
        self._process_pool = process_pool
        self._working_subdir_paths = []
        self._cleanup_done = False
        if not os.path.isdir(self._working_dir):
            os.makedirs(self._working_dir)
        # Start a printer: doing this because
        # we can then re-use the utility functions
        # that work that way and we get timestamps
        # and can also write to a debug file
        self.window_debug_handle = None
        if window_debug_file_name:
            # Make sure the file exists and don't truncate it
            self.window_debug_handle = open(window_debug_file_name,"a")
            self.window_debug_handle.close()
            self.window_debug_handle = open(window_debug_file_name, "r+")
        self._print_queue = queue.Queue()
        self._print_thread = u_utils.PrintThread(self._print_queue,
                                                 window_file_handle=self.window_debug_handle,
                                                 window_size=window_debug_tailed_lines)
        self._print_thread.start()
        self._printer = u_utils.PrintToQueue(self._print_queue, None, True)
        # rpyc.ThreadedService does not seem to call our destructor
        # so we daisy-chain ourselves into the SIGINT handler here
        # in order to do our clean-up
        self._saved_sigint_handler = signal(SIGINT, self._signal)
        # Restore dynamic status, if present
        self._restore_status()
        self._printer.string("{}started, CTRL-C to exit.".format(PROMPT))

    # Call _cleanup() if the destructor is called.
    def __del__(self):
        if not self._cleanup_done:
            self._cleanup()
        if self._saved_sigint_handler:
            # Put the signal handler back as it was
            signal(SIGINT, self._saved_sigint_handler)
            self._saved_sigint_handler = None

#########################################################
# METHODS INTERNAL TO THIS CLASS
#########################################################

    # Call _cleanup() if SIGINT goes off.
    def _signal(self, signum, frame):
        '''Do our clean-up on SIGINT'''
        if not self._cleanup_done:
            self._cleanup()
        if self._saved_sigint_handler:
            # Put the _signal handler back as it was and call it
            # so that the next thing gets the SIGINT
            signal(SIGINT, self._saved_sigint_handler)
            self._saved_sigint_handler(signum, frame)
            self._saved_sigint_handler = None

    # Clean-up: stop the agent [rudely] and
    # close the printer thread/file.
    def _cleanup(self):
        '''Do our clean-up'''
        self._printer.string("{}stopping.".format(PROMPT))
        u_agent.deinit_context_lock()
        u_agent.deinit()
        # Stop the printer
        sleep(1)
        self._print_thread.stop_thread()
        self._print_thread.join()
        if self.window_debug_handle:
            self.window_debug_handle.close()
        self._cleanup_done = True

    # Create a working path: this will be inside
    # the working directory the agent was given
    # at start-up and will otherwise be generated
    # from the url, branch name and, if present,
    # up to AGENT_WORKING_SUBDIR_CONTROLLER_NAME_MAX_LENGTH
    # characters taken from the controller name.
    # If you're wondering why all this complexity,
    # it is to keep path lengths short and at the
    # same time create a name that is human readable
    # and attached to something real.
    def _working_subdir_path_create(self, url, branch, controller_name):
        '''Create a fully formed working directory path'''
        keep_going = True
        branch_rotate = 0
        branch_local = branch
        url_rotate = 0
        url_local = url
        # Remove some character sequences that can appear
        # in URLs that we either don't want in a path or
        # are undifferentiating
        url_local = url_local.replace("http:", "")
        url_local = url_local.replace("https:", "")
        url_local = url_local.replace("/", "")
        while keep_going:
            path = self._working_dir + os.sep
            if controller_name:
                # Take the last N characters of controller_name
                start = len(controller_name) - AGENT_WORKING_SUBDIR_CONTROLLER_NAME_MAX_LENGTH
                if start < 0:
                    start = 0
                path += controller_name[start : len(controller_name)]
            length = AGENT_WORKING_SUBDIR_MAX_LENGTH - len(path)
            # Now need to form a unique name from the url and branch
            # in the room that remains.  Use a little of the URL (1/3rd of
            # the remaining length) and take the rest from the branch
            # since there are likely to be relatively few URLs and lots
            # of different branches.
            # URLs tend to be different from the end, so take the last
            # N characters
            start = int(len(url_local) - (length / 3))
            if start < 0:
                start = 0
            path += url_local[start : len(url_local)]
            length = AGENT_WORKING_SUBDIR_MAX_LENGTH - len(path)
            if branch.startswith("#"):
                # It's actually a hash, so start at the front
                start = 1
            else:
                # Branch names tend to be the same at either end so
                # start in the middle
                start = int((len(branch_local) / 2) - (length / 2))
                if start < 0:
                    start = 0
            end = start + length
            if end > len(branch_local):
                end = len(branch_local)
            path += branch_local[start : end]
            # Now see if we've collided with anything we already have
            reuse_existing = False
            for working_subdir_path in self._working_subdir_paths:
                if working_subdir_path["path"] == path:
                    if ((working_subdir_path["url"] != url) or
                        (working_subdir_path["branch"] != branch) or
                        (working_subdir_path["controller_name"] != controller_name)):
                        # Same path, different url/branch/controller,
                        # need to try again
                        path = ""
                    else:
                        # This url/branch/controller has been loaded
                        # before, we can re-use it
                        reuse_existing = True
                    break
            if path and not reuse_existing:
                # If we have a path and we're not re-using an
                # existing one, check if the path is already
                # present, some fossil, and delete it
                if not u_utils.deltree(path, self._printer, PROMPT):
                    path = ""
            if path:
                keep_going = False
                if not reuse_existing:
                    # If we're not re-using an existing path
                    # save the new one in the list
                    working_subdir_path = {}
                    working_subdir_path["path"] = path
                    working_subdir_path["url"] = url
                    working_subdir_path["branch"] = branch
                    working_subdir_path["controller_name"] = controller_name
                    self._working_subdir_paths.append(working_subdir_path)
                    self._save_status()
            else:
                # If we've not been successful, rotate stuff for
                # the next try
                branch_local = rotate_string(branch_local)
                branch_rotate += 1
                if branch_rotate == len(branch_local):
                    branch_rotate = 0
                    url_local = rotate_string(url_local)
                    url_rotate += 1
                    if url_rotate == len(url_local):
                        keep_going = False
        return path

    # Get the working subdirectory path for the given url, branch
    # and controller name.
    def _working_subdir_path_get(self, url, branch, controller_name):
        '''Return the working subdirectory path'''
        path = ""
        for working_subdir_path in self._working_subdir_paths:
            if working_subdir_path["url"] == url and \
               working_subdir_path["branch"] == branch and \
               working_subdir_path["controller_name"] == controller_name:
                path = working_subdir_path["path"]
                break
        return path

    # Check if the given controller is the current controller
    # and, if not, print out a message with the function_name
    # in it.
    def _locker(self, controller_name, function_name=None):
        '''Check if controller_name is the current locker's'''
        is_locker = True
        if self._controller_name and (controller_name != self._controller_name):
            is_locker = False
            if function_name:
                self._printer.string("{}{}() called by controller {}" \
                                     " but cannot comply, controller" \
                                     " is {}.".format(PROMPT, function_name,
                                                      controller_name,
                                                      self._controller_name))
        return is_locker

    # Save the dynamic status of the agent: call
    # this whenever the state of the fields included
    # below changes.
    def _save_status(self):
        '''Save dynamic status to file'''
        status = {}
        if self._controller_name:
            status["controller_name"] = str(self._controller_name)
        status["instances_activated"] = self._instances_activated
        status["instances_supported"] = self._instances_supported
        status["working_subdir_paths"] = self._working_subdir_paths
        with open(self._working_dir + os.sep + AGENT_DYNAMIC_STATUS_FILE_NAME, "w") as file:
            json.dump(status, file)

    # Restore the dynamic status of the agent: call
    # this at the end of __init__().
    def _restore_status(self):
        '''Restore dynamic status from file'''
        try:
            with open(self._working_dir + os.sep + AGENT_DYNAMIC_STATUS_FILE_NAME, "r") as file:
                try:
                    status = json.load(file)
                    if "controller_name" in status:
                        self._controller_name = str(status["controller_name"])
                    if ("instances_supported" in status) and \
                       (status["instances_supported"] == self._instances_supported):
                        # Only read the activated list in if
                        # the instance supported list is _exactly_ the
                        # same as the one stored, which will be the
                        # case if we got here through exposed_agent_restart(),
                        # otherwise the instances activated may be out of date
                        self._instances_activated = status["instances_activated"]
                    if "working_subdir_paths" in status:
                        for working_subdir_path in status["working_subdir_paths"]:
                            # Only keep working_subdir_paths that exist
                            if ("path" in working_subdir_path) and  \
                               os.path.exists(working_subdir_path["path"]):
                                self._working_subdir_paths.append(working_subdir_path)
                except Exception as ex:
                    self._printer.string("{} error {}{} reading settings file {}.". \
                                         format(PROMPT, type(ex).__name__, str(ex),
                                                AGENT_DYNAMIC_STATUS_FILE_NAME))
        except FileNotFoundError:
            pass

#########################################################
# RPYC STANDARD METHODS
#########################################################

    def on_connect(self, conn):
        self._printer.string("{}connection from {}.". \
                             format(PROMPT, conn._channel.stream.sock.getpeername()[0]))
        if self._connection_count == 0:
            self._printer.string("{}starting agent.".format(PROMPT))
            u_agent.init_context_lock()
        self._connection_count += 1

    def on_disconnect(self, conn):
        self._printer.string("{}a connection was dropped.".format(PROMPT))
        if self._connection_count > 0:
            self._connection_count -= 1
            if self._connection_count == 0:
                self._printer.string("{}no connections left, stopping agent.".format(PROMPT))
                # Deinit the lock first to prevent
                # deadlocks, then stop the agent
                u_agent.deinit_context_lock()
                u_agent.stop()

#########################################################
# METHODS EXPOSED THROUGH RPYC: MISC
#########################################################

    # Print a string to this agent's debug log.
    def exposed_print(self, text):
        '''Print to the agent's debug printer'''
        self._printer.string("{}".format(text))

    # Use this in emergencies to remove the saved
    # dynamic data file; it doesn't do anything else:
    # if you want the dynamic status actually reset
    # you must call exposed_agent_restart() afterwards.
    def exposed_delete_status_file(self):
        '''Delete the saved defaults file'''
        if os.path.isfile(AGENT_DYNAMIC_STATUS_FILE_NAME):
            try:
                os.remove(AGENT_DYNAMIC_STATUS_FILE_NAME)
            except OSError as ex:
                self._printer.string("{} unable to delete \"{}\" {}: \"{}\"".
                                   format(PROMPT, AGENT_DYNAMIC_STATUS_FILE_NAME,
                                          ex.errno, ex.strerror))

    # Stop the agent and empty the working directory, waiting
    # up to wait_time seconds for any instances to finish
    # running before stopping them rudely.  This is a useful
    # clean-up that might be called periodically to free disk
    # space.  If the wait time expires the instances are stopped
    # rudely.  This can be called at any time as it includes
    # its own lock.
    def exposed_stop_and_clean(self, wait_time=AGENT_CLEAN_WAIT_SECONDS, controller_name=None):
        '''Empty base_dir, stopping running processes to do so'''
        success = False
        if self._locker(controller_name, "stop_and_clean"):
            # Wait for the lock
            self._clean_lock.acquire()
            self.exposed_stop(wait_time)
            success = u_utils.deltree(self._working_dir, self._printer, PROMPT)
            if not os.path.isdir(self._working_dir):
                os.makedirs(self._working_dir)
            self._clean_lock.release()
        return success

    # Add a queue to the list of places that get this agent's output
    def exposed_printer_start(self, print_queue, buffer_time=0):
        '''Add a queue to the list of places we send strings to'''
        self._print_thread.add_forward_queue(print_queue, buffer_time=buffer_time)

    # Remove a queue from the list of places that get this agent's output
    def exposed_printer_stop(self, print_queue):
        '''Remove a queue from the list of places we send strings to'''
        self._print_thread.remove_forward_queue(print_queue)

#########################################################
# METHODS EXPOSED THROUGH RPYC: CONTROLLER RELATED
#########################################################

    # Lock the agent to the given controller.
    # While locked others can query the agent
    # but no-one can make it DO anything.
    # Controller names should be kept short since
    # they are used in paths that can already be
    # quite long.  Try NOT to keep an agent locked
    # if at all possible for maximum flexibility.
    # To update or restart an agent, lock it, allow
    # any running instances to stop (or stop them
    # rudely) then you can operate on the agent
    # as a whole safely (update the agent's code,
    # restart the agent, etc.).
    # IMPORTANT: locks survive agent restarts so
    # do make sure that any agent which locks an
    # agent then restarts it reconnects to that
    # agent to unlock it.
    def exposed_lock(self, controller_name):
        '''Lock this agent to the given controller'''
        success = False
        if self._controller_name == controller_name:
            success = True
        else:
            if not self._controller_name:
                self._controller_name = controller_name
                success = True
                self._save_status()
        return success

    # Unlock the agent from the given controller.
    # Use None to [rudely] unlock it in an emergency.
    def exposed_unlock(self, controller_name):
        '''Unlock this agent'''
        success = False
        if not controller_name or (self._controller_name == controller_name):
            self._controller_name = None
            success = True
            self._save_status()
        return success

    # Get the name of the current controller of this
    # agent; returns None if there is no controller.
    def exposed_controller_get(self):
        '''Return the current controller'''
        return self._controller_name

#########################################################
# METHODS EXPOSED THROUGH RPYC: AGENT RELATED
#########################################################

    # Get the name of the branch that this script and all the
    # associated Python scripts are from.
    def exposed_agent_branch_get(self):
        '''Get the name of the branch that this script is on'''
        text = subprocess.check_output(u_utils.subprocess_osify(["git", "rev-parse",
                                                                 "--abbrev-ref", "HEAD"]),
                                       stderr=subprocess.STDOUT,
                                       shell=True) # Jenkins hangs without this
        return text.strip().decode("utf8")

    # Get the hash of the commit that this script and all the
    # associated Python scripts are from.
    def exposed_agent_hash_get(self):
        '''Get the hash of the branch that this script is on'''
        text = subprocess.check_output(u_utils.subprocess_osify(["git", "rev-parse", "HEAD"]),
                                       stderr=subprocess.STDOUT,
                                       shell=True) # Jenkins hangs without this
        return text.strip().decode("utf8")

    # Check out the given url/branch of this script; branch
    # can also be a hash of the desired commit or, if None,
    # master branch is assumed.
    # This is not the same as exposed_check_out(), which
    # puts code into a subdirectory under the path specified by
    # _working_subdir_path_create() for an instance to be run on;
    # we're talking replacing both this script and the u_blah ones
    # it includes here.
    # This should only be called after the agent has been
    # locked to a controller and any running instances
    # [allowed to] stop[ped]. Once this method has returned
    # the agent MUST be restarted to complete the change.
    def exposed_agent_check_out(self, url, branch, controller_name=None):
        '''Check out url/branch into the agent's space (not working dir, replace THIS script)'''
        success = False
        if self._locker(controller_name, "check_out"):
            # Don't need submodules initialised for just the
            # automation scripts, saves time
            success = u_utils.fetch_repo(url, ".", branch, self._printer, PROMPT,
                                         submodule_init=False, force=True)
            if success:
                # Update Unity as well while we're here
                self.exposed_agent_unity_update(controller_name)
                self._printer.string("{}done, please restart the agent.".format(PROMPT))
        return success

    # Restart the agent. WARNING: to accommodate emergency
    # use this method does not do any status checking, aside
    # from checking the controller.  IT IS UP TO YOU to
    # lock the agent, wait for any running instances to stop
    # (or stop them rudely) before the agent is restarted.
    # When a restart occurs the connection to the controller
    # will drop but the lock (and any deactivated instances)
    # WILL BE REMEMBERED: the controller that called
    # exposed_agent_restart() must reconnect to the agent and
    # unlock it before any other controller can use it.
    # If you do not want the lock and deactivated instances
    # to be remembered then call exposed_delete_status_file()
    # before calling this method.
    def exposed_agent_restart(self, controller_name=None):
        '''Restart the agent'''
        if self._locker(controller_name, "agent_restart"):
            # From https://gist.github.com/plieningerweb/39e47584337a516f56da105365a2e4c6
            text = sys.executable
            for item in sys.argv:
                text += " {}".format(item)
            self._printer.string("{}restarting agent with \"{}\", connection" \
                                 " will drop, YOU MUST reconnect.".format(PROMPT, text))
            sleep(1)
            self._cleanup()
            self._process_pool.close()
            self._process_pool.join()
            sleep(5)
            os.execv(sys.executable, ["python"] + sys.argv)
        return False

    # Update the common copy of Unity used by the agent.
    def exposed_agent_unity_update(self, controller_name=None):
        '''Update the common copy of Unity used by the agent'''
        success = False
        if self._locker(controller_name, "agent_unity_update"):
            if self._unity_dir:
                # Don't need submodules initialised for Unity, saves time
                success = u_utils.fetch_repo(u_utils.UNITY_URL,
                                             self._unity_dir, None,
                                             self._printer, PROMPT,
                                             submodule_init=False, force=True)
                if success:
                    self._printer.string("{}Unity has been updated.".format(PROMPT))
                else:
                    self._printer.string("{}unable to update Unity.".format(PROMPT))
            else:
                success = True
                self._printer.string("{}no Unity directory was specified,"          \
                                     " Unity has not been updated.".format(PROMPT))
        return success

    # Deactivate the given instances on this agent.
    # Use None to deactivate the entire agent.
    def exposed_agent_deactivate(self, instances=None, controller_name=None):
        '''Deactivate the instance list or, if none, all instances'''
        if self._locker(controller_name, "agent_deactivate"):
            # Make copies of the array since we don't
            # want to be referring over the network back
            # to the controller.
            instances = deepcopy(instances)
            instances_activated = []
            if instances:
                self._printer.string("{}deactivating instance(s): {}.".   \
                                     format(PROMPT, u_utils.get_instances_text(instances)))
                if self._instances_activated:
                    for instance in self._instances_activated:
                        if (instance not in instances) and (instance not in instances_activated):
                            instances_activated.append(instance)
            else:
                self._printer.string("{}agent deactivated.".format(PROMPT))
            self._instances_activated = instances_activated
            self._save_status()
            text = u_utils.get_instances_text(self._instances_activated)
            if not text:
                text = "none"
            self._printer.string("{}instance(s) activated: {}.".format(PROMPT, text))
        return self._instances_activated

    # Activate the given instances on this agent.
    # Use None to restore all supported instances
    # to activated state.
    def exposed_agent_activate(self, instances=None, controller_name=None):
        '''Activate the instance list or, if none, all instances'''
        if self._locker(controller_name, "agent_activate"):
            # Make copies of the array since we don't
            # want to be referring over the network back
            # to the controller.
            instances = deepcopy(instances)
            instances_activated = self._instances_supported
            if instances:
                text = u_utils.get_instances_text(instances)
                if not text:
                    text = "none"
                self._printer.string("{}activating instance(s): {}".format(PROMPT, text))
                instances_activated = self._instances_activated
                for instance in instances:
                    if self._instances_supported and                     \
                       (instance in self._instances_supported) and       \
                       (not self._instances_activated or                 \
                        (instance not in self._instances_activated)) and \
                       (instance not in instances_activated):
                        instances_activated.append(instance.copy())
            self._instances_activated = instances_activated
            self._save_status()
            text = u_utils.get_instances_text(self._instances_activated)
            if not text:
                text = "none"
            self._printer.string("{}instance(s) activated: {}.".format(PROMPT, text))
        return self._instances_activated

#########################################################
# METHODS EXPOSED THROUGH RPYC: RUNNING INSTANCES
#########################################################

    # Check the given url/branch of code out into the working
    # directory; branch can also be a hash of the desired commit or,
    # if None, master is assumed.  The code will be checked out
    # into a sub-directory of _working_subdir_path_create()
    # which will be emptied first if clean is True.
    def exposed_check_out(self, url, branch, controller_name=None, clean=False):
        '''Check out the given branch of url'''
        success = False
        if self._locker(controller_name, "check_out"):
            # Only do anything if the agent is activated
            if self._instances_activated:
                success = True
                # Stop cleans getting in while we're checking stuff out
                self._clean_lock.acquire()
                # The directory path is based on the url, branch and
                # controller names
                ubxlib_dir = self._working_subdir_path_create(url, branch, controller_name)
                if ubxlib_dir:
                    # Add to this the sub-directory name:
                    ubxlib_dir += os.sep + AGENT_UBXLIB_SUBDIR
                    if clean:
                        success = u_utils.deltree(ubxlib_dir, self._printer, PROMPT)
                    if success:
                        success = u_utils.fetch_repo(url, ubxlib_dir, branch,
                                                     self._printer, PROMPT,
                                                     submodule_init=True, force=True)
                self._clean_lock.release()
            else:
                self._printer.string("{}agent is deactivated.".format(PROMPT))
        return success

    # Run the list of instances. The code on which the instances are to
    # be run must have been checked out beforehand using exposed_check_out().
    # Note that runs are always cleaned because of the way
    # _working_subdir_path works; it cannot guarantee not to re-use
    # an old directory.
    def exposed_session_run(self, database, instances, filter_string, url,
                            branch, summary_report_file, test_report_file,
                            debug_file, session_name=None, controller_name=None,
                            abort_on_first_failure=False):
        '''Run some instances on the agent'''
        return_value = -1
        instances = u_utils.copy_two_level_list(instances)

        if self._locker(controller_name, "run_instances"):
            # Make copies of the arrays and dictionaries since we don't
            # want to be referring back to the controller over the network.
            database = deepcopy(database)
            instances = deepcopy(instances)
            # This to prevent a clean occurring while we're starting a run
            self._clean_lock.acquire()
            self._run_called += 1
            self._clean_lock.release()
            # Check for instances we don't support
            if self._instances_activated:
                return_value = 0
                for instance in instances:
                    if instance not in self._instances_activated:
                        self._printer.string("{}{} is not a supported and activated instance.".   \
                                             format(PROMPT, u_utils.get_instance_text(instance)))
                        return_value = -1
                if return_value == 0:
                    return_value = -1
                    # If nothing is already running we can do a
                    # HW reset first
                    hw_reset=False
                    if self.exposed_instance_running_count_get() == 0:
                        hw_reset=True
                    if u_agent.start(hw_reset=hw_reset):
                        text = ""
                        if controller_name:
                            text = " controller"
                        text += " url {} branch {}".format(url, branch)
                        working_dir = self._working_subdir_path_get(url, branch, controller_name)
                        if working_dir:
                            ubxlib_dir = working_dir + os.sep + AGENT_UBXLIB_SUBDIR
                            instances_dir = working_dir + os.sep + AGENT_INSTANCES_SUBDIR_NAME
                            if os.path.isdir(instances_dir):
                                u_utils.deltree(instances_dir, self._printer, PROMPT)
                            try:
                                os.makedirs(instances_dir)
                            except (OSError, FileNotFoundError):
                                pass
                            if os.path.isdir(instances_dir):
                                return_value = u_agent.session_run(database, instances,
                                                                   filter_string, ubxlib_dir,
                                                                   instances_dir,
                                                                   True, summary_report_file,
                                                                   test_report_file,
                                                                   debug_file, self._process_pool,
                                                                   session_name,
                                                                   self._print_queue,
                                                                   "[" + PROMPT.strip(" :") + "] ",
                                                                   abort_on_first_failure,
                                                                   self._unity_dir)
                            else:
                                self._printer.string("{}unable to create empty directory {}" \
                                                     " for{}.".format(PROMPT, working_dir, text))
                        else:
                            self._printer.string("{}unable to find ubxlib directory" \
                                                 " for{}.".format(PROMPT, text))
                else:
                    self._printer.string("{}activated instance(s):{}.". \
                                         format(PROMPT,
                                                u_utils.get_instances_text(self._instances_activated)))
            else:
                self._printer.string("{}agent is deactivated.".format(PROMPT))
            if u_agent.instance_running_count() == 0:
                u_agent.stop()
            self._run_called -= 1
        return return_value

    # Get the path at which the build/test products can be
    # found on this agent.  The log files passed to
    # exposed_run_instances() can be found in this directory,
    # in the root and one level below.
    def exposed_result_path_get(self, url, branch, controller_name=None):
        '''Get the path to the products of a test run'''
        path = self._working_subdir_path_get(url, branch, controller_name)
        if path:
            path += os.sep + AGENT_INSTANCES_SUBDIR_NAME
        return path

    # Stop the given session.  Call this while exposed_session_run()
    # is in progress to make it exit gracefully, in its own time.
    def exposed_session_abort(self, session_name, controller_name=None):
        '''Stop the named session'''
        success = False
        if self._locker(controller_name, "session_abort"):
            success = u_agent.session_abort(session_name)
        return success

    # Stop any running sessions, waiting up to wait_time
    # for them to stop.  Specify a wait_time of zero to
    # stop them immediately, rudely.  It is a good idea
    # to lock the agent before calling this as otherwise
    # another peer could start a session at any time afterwards.
    # Note: this does not deactivate the agent, it simply
    # stops the current set of things from running.
    def exposed_stop(self, wait_time=AGENT_CLEAN_WAIT_SECONDS, controller_name=None):
        '''Stop an agent, waiting to do so gracefully'''
        success = False
        if self._locker(controller_name, "stop"):
            while (self._run_called > 0) and (wait_time > 0):
                self._printer.string("{}{} session(s) running, {} instance(s)," \
                                     " waiting {} second(s) for them to stop.".       \
                                     format(PROMPT, u_agent.session_running_count(),
                                            u_agent.instance_running_count(), wait_time))
                sleep(AGENT_CHECK_PERIOD_SECONDS)
                wait_time -= AGENT_CHECK_PERIOD_SECONDS
            u_agent.stop()
            success = True
        return success

    # Archive the given files from the given directory (and
    # sub-directories) to the given URL.  The URL might, for instance, be
    # a Nexus server, so something like http://nexus.myplace.com:8345/archives;
    # the directory structure will be preserved.
    # Recurse is how many directory levels down to recurse, 0 for no recursion.
    def exposed_archive_to_url(self, local_directory, file_list, archive_url, recurse=0,
                               archive_credentials=None):
        '''Archive the given files from the given directory to the given URL'''
        success = False
        if local_directory and (os.path.isdir(local_directory)) and file_list and archive_url:
            self._printer.string("{}archiving {} level(s) from"          \
                                 " \"{}\" to {}...".format(PROMPT, recurse + 1,
                                                           local_directory, archive_url))
            # Make a copy of the array since we don't
            # want to be referring back to the controller
            # over the network.
            file_list = deepcopy(file_list)

            success = True
            for root, _directories, files in os.walk(local_directory):
                if root[len(local_directory):].count(os.sep) <= recurse:
                    for file in files:
                        if file in file_list:
                            source = os.path.join(root, file)
                            destination = archive_url + \
                                          source[len(local_directory):].replace("\\", "/")
                            self._printer.string("{}PUTing {} to {}...".format(PROMPT, source, destination))
                            multipart_encoder = MultipartEncoder({self._name: (file, open(source, "rb"), "text/plain")})
                            try:
                                if archive_credentials:
                                    response = requests.put(destination, data=multipart_encoder,
                                                            headers={"Content-Type": multipart_encoder.content_type,
                                                                     "Content-Disposition": "inline"},
                                                            auth=tuple(archive_credentials.split(":")))
                                else:
                                    response = requests.put(destination, data=multipart_encoder,
                                                            headers={"Content-Type": multipart_encoder.content_type,
                                                                     "Content-Disposition": "inline"})
                                self._printer.string("{}...returned result {}.".format(PROMPT, response.status_code))
                                if response.status_code != 201:
                                    success = False
                            except (ProtocolError, ConnectionError, TimeoutError):
                                self._printer.string("{}...failed because of a connection error.".format(PROMPT))
                                success = False
        return success

    # Copy the given files from the given directory (and sub-directories)
    # to the given handle as a single binary stream.  Recurse is how many
    # directory levels down to recurse, 0 for no recursion.
    def exposed_copy(self, destination_handle, local_directory, file_list, recurse=0):
        '''Copy the given files from the given directory to the given handle'''
        count = 0
        success = False
        if destination_handle and local_directory and (os.path.isdir(local_directory)) \
           and file_list:
            self._printer.string("{}copying {} level(s) from"          \
                                 " \"{}\"...".format(PROMPT, recurse + 1,
                                                     local_directory))
            # Make a copy of the array since we don't
            # want to be referring back to the controller
            # over the network.
            file_list = deepcopy(file_list)

            success = True
            for root, _directories, files in os.walk(local_directory):
                if root[len(local_directory):].count(os.sep) <= recurse:
                    for file in files:
                        if file in file_list:
                            source = os.path.join(root, file)
                            self._printer.string("{}copying {}...".format(PROMPT, source))
                            try:
                                with open(source, "rb") as handle:
                                    destination_handle.write(handle.read())
                                    count += 1
                            except OSError:
                                success = False
                else:
                    break
            self._printer.string("{}the contents of {} file(s) copied.".format(PROMPT, count))

        return success

#########################################################
# METHODS EXPOSED THROUGH RPYC: INFORMATION
#########################################################

    # Get the name of the agent.
    def exposed_name_get(self):
        '''Get the name of the agent'''
        return self._name

    # Get the instance list supported by this agent.
    # These will have been specified when the agent
    # was started.  They will be delivered as a list
    # of lists, e.g. [[0, 0], [13, 1, 0]...].
    # The caller should take a copy of the list before
    # doing anything with it in order to avoid (a)
    # messing us up and (b) having to confer over a
    # network link using RPyC for every transaction.
    def exposed_instances_supported_get(self):
        '''Return the supported instances'''
        return self._instances_supported

    # Get the list of currently activated instances on this
    # agent as a list of lists, e.g. [[0, 0], [13, 1, 0]...].
    # The caller should take a copy of the list before
    # doing anything with it in order to avoid (a)
    # messing us up and (b) having to confer over a
    # network link using RPyC for every transaction.
    def exposed_instances_activated_get(self):
        '''Return the activated instances'''
        return self._instances_activated

    # Get the list of instances deactivated on this
    # agent as a list of lists, e.g. [[0, 0], [13, 1, 0]...].
    # This may be useful if an agent is to be restarted and
    # the deactivated status of any instances has not been
    # preserved for some reason.
    # The caller should take a copy of the list before
    # doing anything with it in order to avoid (a)
    # messing us up and (b) having to confer over a
    # network link using RPyC for every transaction.
    def exposed_instances_deactivated_get(self):
        '''Return the deactivated instances'''
        instances = None
        if self._instances_supported:
            if not self._instances_activated:
                instances = self._instances_supported
            else:
                for instance in self._instances_supported:
                    if instance not in self._instances_activated:
                        instances.append(instance.copy())
        return instances

    # Get the number of sessions currently running on
    # this agent.
    def exposed_session_running_count_get(self):
        '''Get the number of sessions running on this agent'''
        return u_agent.session_running_count()

    # Get the names of the sessions currently running on
    # this agent (may be None since sessions are not
    # required to have names).
    def exposed_session_running_names_get(self):
        '''Get the names (where present) of sessions running on this agent'''
        return u_agent.session_running_names()

    # Get the total number of instances, across all sessions,
    # running on this agent
    def exposed_instance_running_count_get(self, session_name=None):
        '''Get the number of instances running on this agent'''
        return u_agent.instance_running_count(session_name)

    # Get the list of instances running on this agent,
    # where each item is a list forming the instance name,
    # e.g. [[0, 0], [0, 1], [13, 1, 0]...]
    def exposed_instances_running_get(self, session_name=None):
        '''Get the instances running'''
        return u_agent.instances_running(session_name)

    # As exposed_instances_running_get() except this
    # is the list of instances that are free to run,
    # out of those activated (which is those supported
    # unless any have been deactivated).
    # The caller should take a copy of the list before
    # doing anything with it in order to avoid (a)
    # messing us up and (b) having to confer over a
    # network link using RPyC for every transaction.
    def exposed_instances_free_get(self):
        '''Get the instances NOT running'''
        instances = []
        instances_running = u_agent.instances_running()
        for instance in self._instances_activated:
            if instance not in instances_running:
                instances.append(instance.copy())
        return instances

def parse_instances(instances_text):
    '''Parse "0.0 1 13.0.1" into a list of lists [[0, 0], [1], [13, 0, 1]]'''
    instances = []
    bad = False
    for part in instances_text:
        instance = []
        if not bad:
            for item in part.split("."):
                try:
                    instance.append(int(item))
                except ValueError:
                    # Rubbish
                    bad = True
                    break
            if instance:
                instances.append(instance[:])
        else:
            break
    if bad:
        instances = []
    return instances

if __name__ == "__main__":
    freeze_support()

    # Switch off traceback to stop the horrid developmenty prints
    #sys.tracebacklimit = 0
    PARSER = argparse.ArgumentParser(description="Run a ubxlib"      \
                                     " test service, AgentService,"  \
                                     " available over RPyC.")
    PARSER.add_argument("-p", default=AGENT_SERVICE_PORT, help="the" \
                        " port number to listen on, default " +      \
                        str(AGENT_SERVICE_PORT) + ".")
    PARSER.add_argument("-n", help="a name for this agent.")
    PARSER.add_argument("-u", help="directory into which Unity"     \
                        " should be fetched and used by all"        \
                        " instances; if not specified each"         \
                        " instance will fetch its own copy as"      \
                        " required.")
    PARSER.add_argument("-d", help="debug output should be"         \
                        " written to the given file; it will be"    \
                        " tailed at -t lines.")
    PARSER.add_argument("-t", type=int, default=10000, help="debug" \
                        " output should be tailed at this number"  \
                        " of lines.")
    PARSER.add_argument("working_dir", help="the directory to use,"  \
                        " should be really short to avoid path length" \
                        " issues e.g. c:\\work is good or, if you are" \
                        " on Windows, use a subst; this script must"   \
                        " NOT be being run from inside this directory.")
    PARSER.add_argument("instances", nargs='*', help="the instances"  \
                        " this agent supports e.g. 0 0.0 13.0.1 17")
    ARGS = PARSER.parse_args()

    if ARGS.n:
        PROMPT = ARGS.n + ": "

    INSTANCES = parse_instances(ARGS.instances)

    print("{}listening on port {}, working directory \"{}\"".    \
          format(PROMPT, ARGS.p, ARGS.working_dir), end="")
    TEXT = " none"
    if INSTANCES:
        TEXT = u_utils.get_instances_text(INSTANCES)
    print(", instance(s) supported:{}".format(TEXT), end="")
    if ARGS.d:
        print(", debug being written to \"{}\", tailed at {} lines". \
              format(ARGS.d, ARGS.t), end="")
    if ARGS.u:
        print(", Unity being fetched to \"{}\"".format(ARGS.u), end="")
    print(".")

    # From this post:
    # https://stackoverflow.com/questions/11312525/catch-ctrlc-sigint-and-exit-multiprocesses-gracefully-in-python
    # ...create a pool of worker processes to run our
    # instances, then they will handle sigint correctly
    # and tidy up after themselves.

    # SIGINT is ignored while the pool is created
    ORIGINAL_SIGINT_HANDLER = signal(SIGINT, SIG_IGN)
    PROCESS_POOL = u_agent.NoDaemonPool(len(INSTANCES))
    signal(SIGINT, ORIGINAL_SIGINT_HANDLER)

    try:
        # Run  AgentService at a higher priority than
        # the other threads so that it is responsive to
        # u_controller_client.py
        u_utils.set_process_prio_high()
        THREAD = rpyc.utils.server.ThreadedServer(AgentService(ARGS.working_dir, ARGS.n,
                                                               ARGS.u, ARGS.d, ARGS.t,
                                                               INSTANCES, PROCESS_POOL),
                                                  port=ARGS.p, auto_register=True,
                                                  protocol_config={# Need this to allow lists to be
                                                                   # copied by the far end
                                                                   "allow_pickle": True,
                                                                   "sync_request_timeout": None})
        THREAD.start()
    except KeyboardInterrupt:
        print("{}caught CTRL-C, stopping.".format(PROMPT))
        PROCESS_POOL.terminate()
        PROCESS_POOL.join()
        # Note: ThreadedServer exits on CTRL-C, no need to worry about it
